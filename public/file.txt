import { useState } from 'react'
import { useForm, Controller } from 'react-hook-form'
import './App.css'
import * as d3 from 'd3'
import { useEffect, useRef } from 'react'
import type { MouseEvent } from 'react'

// Types for form data
interface FormData {
  inputType: 'json' | 'path';
  jsonInput?: string;
  pathInput?: string;
}

// Type for folder tree node
interface FolderNode {
  name: string;
  children?: FolderNode[];
  // Optionally, add more fields as needed
}

// Utility: Parse JSON input into FolderNode
function parseJsonInput(json: string): FolderNode | null {
  try {
    const data = JSON.parse(json);
    // Assume user input is already a valid tree structure
    // Optionally, normalize here if needed
    return data;
  } catch {
    return null;
  }
}

// Utility: Parse folder path string into FolderNode
function parsePathInput(path: string): FolderNode {
  // Split by backslash or forward slash
  const segments = path.split(/\\|\//).filter(Boolean);
  if (segments.length === 0) {
    return { name: '', children: [] };
  }
  // Build nested structure
  let node: FolderNode = { name: segments[0], children: [] };
  let current = node;
  for (let i = 1; i < segments.length; i++) {
    const child: FolderNode = { name: segments[i], children: [] };
    current.children!.push(child);
    current = child;
  }
  return node;
}

// Helper: Get path for a node
function getNodePath(node: FolderNode, parentPath: string[] = []): string[] {
  if (!node) return parentPath;
  return [...parentPath, node.name];
}

// Helper: Recursively clone and collapse/expand nodes
function cloneWithCollapse(node: FolderNode, collapsed: Record<string, boolean>, path: string[] = []): FolderNode {
  const nodePath = [...path, node.name].join('/');
  if (collapsed[nodePath] && node.children && node.children.length > 0) {
    return { ...node, children: undefined };
  }
  return {
    ...node,
    children: node.children?.map(child => cloneWithCollapse(child, collapsed, [...path, node.name]))
  };
}

// D3 Tree Visualization Component with zoom, pan, tooltips, expand/collapse
function FolderTreeD3({ tree, collapsed, setCollapsed, selectedNodePath, setSelectedNodePath, search }: {
  tree: FolderNode,
  collapsed: Record<string, boolean>,
  setCollapsed: (updater: (prev: Record<string, boolean>) => Record<string, boolean>) => void,
  selectedNodePath: string | null,
  setSelectedNodePath: (p: string) => void,
  search: string
}) {
  const svgRef = useRef<SVGSVGElement | null>(null);
  const gRef = useRef<SVGGElement | null>(null);
  const [tooltip, setTooltip] = useState<{ x: number; y: number; content: string } | null>(null);
  const [zoomTransform, setZoomTransform] = useState<d3.ZoomTransform | null>(null);

  // Collapse/expand handler
  const handleNodeClick = (d: d3.HierarchyPointNode<FolderNode>) => {
    const path = d.ancestors().reverse().map(n => n.data.name).join('/');
    setCollapsed(prev => ({ ...prev, [path]: !prev[path] }));
    setSelectedNodePath(path);
  };

  // Tooltip handlers
  const handleNodeMouseOver = (event: MouseEvent, d: d3.HierarchyPointNode<FolderNode>) => {
    const path = d.ancestors().reverse().map(n => n.data.name).join('/');
    setTooltip({
      x: event.clientX,
      y: event.clientY,
      content: `Name: ${d.data.name}\nPath: ${path}`
    });
  };
  const handleNodeMouseOut = () => setTooltip(null);

  useEffect(() => {
    if (!tree || !svgRef.current || !gRef.current) return;
    d3.select(gRef.current).selectAll('*').remove();

    // Apply collapse state
    const collapsedTree = cloneWithCollapse(tree, collapsed);
    const root = d3.hierarchy(collapsedTree, d => d.children) as d3.HierarchyPointNode<FolderNode>;
    const treeLayout = d3.tree<FolderNode>().nodeSize([40, 160]);
    treeLayout(root);

    // Calculate SVG size based on tree
    const width = 600;
    const height = Math.max(300, root.height * 60 + 60);

    // Calculate horizontal center offset
    const nodes = root.descendants() as d3.HierarchyPointNode<FolderNode>[];
    const minX = Math.min(...nodes.map(n => n.x));
    const maxX = Math.max(...nodes.map(n => n.x));
    const treeHeight = maxX - minX;
    const centerY = width / 2;
    const centerX = (height - treeHeight) / 2 - minX;

    // Set up zoom
    const svg = d3.select(svgRef.current)
      .attr('width', '100%')
      .attr('height', height)
      .attr('viewBox', `0 0 ${width} ${height}`)
      .style('background', '#f8fafc')
      .style('border-radius', '12px');

    const g = d3.select(gRef.current)
      .attr('transform', zoomTransform ? zoomTransform.toString() : `translate(${centerY},${centerX})`);

    // Draw links
    g.append('g')
      .selectAll('path')
      .data(root.links() as d3.HierarchyPointLink<FolderNode>[])
      .join('path')
      .attr('d', d3.linkHorizontal<d3.HierarchyPointLink<FolderNode>, d3.HierarchyPointNode<FolderNode>>()
        .x(d => d.y - width / 2)
        .y(d => d.x - minX)
      )
      .attr('fill', 'none')
      .attr('stroke', '#94a3b8')
      .attr('stroke-width', 2);

    // Draw nodes
    const node = g.append('g')
      .selectAll<SVGGElement, d3.HierarchyPointNode<FolderNode>>('g')
      .data(nodes)
      .join('g')
      .attr('transform', d => `translate(${d.y - width / 2},${d.x - minX})`)
      .style('cursor', 'pointer')
      .on('click', (event, d) => {
        event.stopPropagation();
        handleNodeClick(d);
      })
      .on('mouseover', (event, d) => handleNodeMouseOver(event, d))
      .on('mouseout', handleNodeMouseOut);

    node.append('circle')
      .attr('r', 16)
      .attr('fill', d => {
        const path = d.ancestors().reverse().map(n => n.data.name).join('/');
        if (selectedNodePath && path === selectedNodePath) return '#f59e42';
        if (search && d.data.name.toLowerCase().includes(search.toLowerCase())) return '#22d3ee';
        return '#6366f1';
      })
      .attr('stroke', d => {
        const path = d.ancestors().reverse().map(n => n.data.name).join('/');
        return selectedNodePath && path === selectedNodePath ? '#ea580c' : 'none';
      })
      .attr('stroke-width', d => {
        const path = d.ancestors().reverse().map(n => n.data.name).join('/');
        return selectedNodePath && path === selectedNodePath ? 4 : 0;
      });

    node.append('text')
      .text(d => d.data.name)
      .attr('dy', '0.35em')
      .attr('x', d => d.children ? -22 : 22)
      .attr('text-anchor', d => d.children ? 'end' : 'start')
      .attr('font-size', 15)
      .attr('fill', '#22223b');

    // D3 zoom behavior
    const zoom = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.3, 2])
      .on('zoom', (event) => {
        setZoomTransform(event.transform);
      });
    svg.call(zoom as any);
  }, [tree, collapsed, zoomTransform, selectedNodePath, search]);

  // Tooltip rendering
  return (
    <div style={{ position: 'relative', width: '100%' }}>
      <svg ref={svgRef} style={{ width: '100%', minHeight: 300 }}>
        <g ref={gRef}></g>
      </svg>
      {tooltip && (
        <div
          style={{
            position: 'fixed',
            left: tooltip.x + 12,
            top: tooltip.y + 12,
            background: 'rgba(30,41,59,0.97)',
            color: '#fff',
            padding: '8px 14px',
            borderRadius: 8,
            fontSize: 14,
            pointerEvents: 'none',
            zIndex: 1000,
            whiteSpace: 'pre-line',
            boxShadow: '0 2px 8px 0 rgba(30,41,59,0.18)'
          }}
        >
          {tooltip.content}
        </div>
      )}
    </div>
  );
}

function App() {
  const [inputType, setInputType] = useState<'json' | 'path'>(() => {
    return (localStorage.getItem('inputType') as 'json' | 'path') || 'json';
  });
  const [jsonInput, setJsonInput] = useState(() => localStorage.getItem('jsonInput') || '');
  const [pathInput, setPathInput] = useState(() => localStorage.getItem('pathInput') || '');
  const [parsedTree, setParsedTree] = useState<FolderNode | null>(null);
  const [search, setSearch] = useState(() => localStorage.getItem('search') || '');
  const [selectedNodePath, setSelectedNodePath] = useState<string | null>(() => localStorage.getItem('selectedNodePath'));
  const [collapsed, setCollapsed] = useState<Record<string, boolean>>(() => {
    try {
      return JSON.parse(localStorage.getItem('collapsed') || '{}');
    } catch {
      return {};
    }
  });

  // Persist state in localStorage
  useEffect(() => { localStorage.setItem('inputType', inputType); }, [inputType]);
  useEffect(() => { localStorage.setItem('jsonInput', jsonInput); }, [jsonInput]);
  useEffect(() => { localStorage.setItem('pathInput', pathInput); }, [pathInput]);
  useEffect(() => { localStorage.setItem('search', search); }, [search]);
  useEffect(() => { localStorage.setItem('selectedNodePath', selectedNodePath || ''); }, [selectedNodePath]);
  useEffect(() => { localStorage.setItem('collapsed', JSON.stringify(collapsed)); }, [collapsed]);

  // Parse input on submit
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    let tree: FolderNode | null = null;
    if (inputType === 'json' && jsonInput) {
      try { tree = JSON.parse(jsonInput); } catch {}
    } else if (inputType === 'path' && pathInput) {
      tree = parsePathInput(pathInput);
    }
    setParsedTree(tree);
    setSelectedNodePath(null);
  };

  // Search helpers
  function findNodeByName(node: FolderNode, name: string, path: string[] = []): string | null {
    if (node.name.toLowerCase().includes(name.toLowerCase())) {
      return [...path, node.name].join('/');
    }
    if (node.children) {
      for (const child of node.children) {
        const found = findNodeByName(child, name, [...path, node.name]);
        if (found) return found;
      }
    }
    return null;
  }

  // Sidebar node info
  let selectedNode: FolderNode | null = null;
  function findNodeByPath(node: FolderNode, path: string[]): FolderNode | null {
    if (path.length === 0) return node;
    if (node.name === path[0]) {
      if (path.length === 1) return node;
      if (node.children) {
        for (const child of node.children) {
          const found = findNodeByPath(child, path.slice(1));
          if (found) return found;
        }
      }
    }
    return null;
  }
  if (parsedTree && selectedNodePath) {
    selectedNode = findNodeByPath(parsedTree, selectedNodePath.split('/'));
  }

  // Handle search
  useEffect(() => {
    if (search && parsedTree) {
      const foundPath = findNodeByName(parsedTree, search);
      if (foundPath) setSelectedNodePath(foundPath);
    }
  }, [search, parsedTree]);

  // In App component, update setCollapsed to use functional form
  const handleSetCollapsed = (updater: (prev: Record<string, boolean>) => Record<string, boolean>) => {
    setCollapsed(updater);
  };

  // Pass handleSetCollapsed to FolderTreeD3
  return (
    <div style={{ display: 'flex', gap: 32, alignItems: 'flex-start', justifyContent: 'center' }}>
      <div className="app-container">
        <h1>Folder Tree Visualizer</h1>
        <form onSubmit={handleSubmit} className="input-form">
          <div>
            <label>
              <input
                type="radio"
                value="json"
                checked={inputType === 'json'}
                onChange={() => setInputType('json')}
              /> JSON Input
              <input
                type="radio"
                value="path"
                checked={inputType === 'path'}
                onChange={() => setInputType('path')}
                style={{ marginLeft: 16 }}
              /> Folder Path Input
            </label>
          </div>
          {inputType === 'json' && (
            <div>
              <label>JSON Input:</label>
              <textarea
                value={jsonInput}
                onChange={e => setJsonInput(e.target.value)}
                rows={6}
                cols={40}
                required
              />
            </div>
          )}
          {inputType === 'path' && (
      <div>
              <label>Folder Path Input:</label>
              <input
                type="text"
                value={pathInput}
                onChange={e => setPathInput(e.target.value)}
                required
              />
            </div>
          )}
          <button type="submit">Submit</button>
        </form>
        <div className="search-bar">
          <input
            type="text"
            placeholder="Search node by name..."
            value={search}
            onChange={e => setSearch(e.target.value)}
          />
        </div>
        {parsedTree && (
          <div className="d3-tree-container">
            <FolderTreeD3
              tree={parsedTree}
              collapsed={collapsed}
              setCollapsed={handleSetCollapsed}
              selectedNodePath={selectedNodePath}
              setSelectedNodePath={setSelectedNodePath}
              search={search}
            />
          </div>
        )}
      </div>
      {/* Sidebar */}
      <div className="sidebar">
        <h2>Node Details</h2>
        {selectedNode ? (
          <>
            <div><span className="node-detail-label">Name:</span> <span className="node-detail-value">{selectedNode.name}</span></div>
            <div><span className="node-detail-label">Path:</span> <span className="node-detail-value">{selectedNodePath}</span></div>
            {selectedNode.children && (
              <div><span className="node-detail-label">Children:</span> <span className="node-detail-value">{selectedNode.children.length}</span></div>
            )}
          </>
        ) : (
          <div className="empty">Select a node to see details</div>
        )}
      </div>
    </div>
  );
}

export default App
